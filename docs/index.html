<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nine Realities Netcode Model | Technical Documentation</title>
    <meta name="description" content="Formal N+1 concurrent simulation model for competitive multiplayer netcode. Research-backed analysis of client-server reconciliation.">
        <meta name="keywords" content="netcode, network simulation, multiplayer games, N+1 model, concurrent realities, game development, Unity netcode, Unreal netcode, deterministic simulation, authoritative server">
        <meta property="og:title" content="Nine Realities Netcode Model | Technical Documentation">
        <meta property="og:description" content="Formal N+1 concurrent simulation model for competitive multiplayer netcode. Research-validated technical framework.">
        <meta property="og:type" content="website">
        <meta property="og:url" content="https://powder-ranger.github.io/nine-realities-netcode/">
        <meta name="twitter:card" content="summary_large_image">
        <meta name="twitter:title" content="Nine Realities Netcode Model">
        <meta name="twitter:description" content="Formal N+1 concurrent simulation model for competitive multiplayer netcode.">
    
    <style>
        :root {
            --color-bg: #0d1117;
            --color-surface: #161b22;
            --color-card-border: #30363d;
            --color-border: #21262d;
            --color-text-primary: #c9d1d9;
            --color-text-secondary: #8b949e;
            --color-accent: #58a6ff;
            --color-accent-hover: #79c0ff;
            --color-success: #3fb950;
            --color-warning: #d29922;
            --radius-sm: 6px;
            --radius-md: 8px;
            --radius-lg: 12px;
            --space-8: 8px;
            --space-12: 12px;
            --space-16: 16px;
            --space-24: 24px;
            --space-32: 32px;
            --font-size-sm: 0.875rem;
            --font-size-base: 1rem;
            --font-size-lg: 1.125rem;
            --font-size-xl: 1.5rem;
            --font-size-2xl: 2rem;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background: var(--color-bg);
            color: var(--color-text-primary);
            line-height: 1.6;
        }
        
        .hero {
            background: linear-gradient(135deg, #1a1f2e 0%, #0d1117 100%);
            border-bottom: 1px solid var(--color-card-border);
            padding: var(--space-32) var(--space-24);
            text-align: center;
        }
        
        .hero h1 {
            font-size: var(--font-size-2xl);
            font-weight: 600;
            margin-bottom: var(--space-12);
            background: linear-gradient(90deg, var(--color-accent) 0%, #bc8cff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .hero p {
            font-size: var(--font-size-lg);
            color: var(--color-text-secondary);
            max-width: 700px;
            margin: 0 auto var(--space-24);
        }
        
        .download-buttons {
            display: flex;
            gap: var(--space-12);
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .btn {
            display: inline-flex;
            align-items: center;
            gap: var(--space-8);
            padding: 10px 20px;
            border-radius: var(--radius-md);
            font-weight: 500;
            text-decoration: none;
            transition: all 0.2s;
            border: 1px solid transparent;
        }
        
        .btn-primary {
            background: var(--color-accent);
            color: #fff;
        }
        
        .btn-primary:hover {
            background: var(--color-accent-hover);
            transform: translateY(-2px);
        }
        
        .btn-outline {
            border-color: var(--color-card-border);
            color: var(--color-text-primary);
        }
        
        .btn-outline:hover {
            background: var(--color-surface);
            border-color: var(--color-accent);
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: var(--space-24);
        }
        
        .tabs {
            display: flex;
            gap: var(--space-8);
            border-bottom: 1px solid var(--color-border);
            margin-bottom: var(--space-24);
            flex-wrap: wrap;
        }
        
        .tab {
            padding: 12px 20px;
            cursor: pointer;
            border: none;
            background: none;
            color: var(--color-text-secondary);
            font-size: var(--font-size-base);
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }
        
        .tab:hover {
            color: var(--color-text-primary);
        }
        
        .tab.active {
            color: var(--color-accent);
            border-bottom-color: var(--color-accent);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .section-card {
            background: var(--color-surface);
            border: 1px solid var(--color-card-border);
            border-radius: var(--radius-lg);
            padding: var(--space-24);
            margin-bottom: var(--space-24);
        }
        
        .section-card h2 {
            font-size: var(--font-size-xl);
            margin-bottom: var(--space-16);
            color: var(--color-accent);
        }
        
        .section-card h3 {
            font-size: var(--font-size-lg);
            margin: var(--space-24) 0 var(--space-12);
            color: var(--color-text-primary);
        }
        
        .section-card p, .section-card li {
            color: var(--color-text-secondary);
            line-height: 1.8;
        }
        
        .section-card ul {
            margin: var(--space-16) 0;
            padding-left: var(--space-24);
        }
        
        .section-card li {
            margin-bottom: var(--space-8);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--space-16);
            margin: var(--space-24) 0;
        }
        
        .stat-card {
            background: var(--color-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            padding: var(--space-16);
            text-align: center;
        }
        
        .stat-value {
            font-size: var(--font-size-2xl);
            font-weight: 700;
            color: var(--color-accent);
            display: block;
        }
        
        .stat-label {
            font-size: var(--font-size-sm);
            color: var(--color-text-secondary);
            margin-top: var(--space-8);
        }
        
        .interactive-sim {
            background: var(--color-surface);
            border: 1px solid var(--color-card-border);
            border-radius: var(--radius-lg);
            padding: var(--space-24);
            margin: var(--space-24) 0;
        }
        
        .interactive-sim h3 {
            margin-bottom: var(--space-16);
            color: var(--color-accent);
        }
        
        #netcodeCanvas {
            width: 100%;
            max-width: 800px;
            height: 400px;
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            background: var(--color-bg);
            display: block;
            margin: 0 auto;
        }
        
        .sim-controls {
            display: flex;
            gap: var(--space-12);
            margin-top: var(--space-16);
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .slider-control {
            margin-top: var(--space-16);
        }
        
        .slider-control label {
            display: block;
            margin-bottom: var(--space-8);
            color: var(--color-text-secondary);
        }
        
        .slider-control input[type="range"] {
            width: 100%;
            max-width: 400px;
        }
        
        code {
            background: var(--color-bg);
            padding: 2px 6px;
            border-radius: var(--radius-sm);
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: var(--color-accent);
        }
        
        pre {
            background: var(--color-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            padding: var(--space-16);
            overflow-x: auto;
            margin: var(--space-16) 0;
        }
        
        pre code {
            background: none;
            padding: 0;
        }
        
        .badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: var(--radius-sm);
            font-size: var(--font-size-sm);
            font-weight: 500;
            margin-right: var(--space-8);
        }
        
        .badge-success {
            background: var(--color-success);
            color: #fff;
        }
        
        .badge-warning {
            background: var(--color-warning);
            color: #000;
        }
        
        .highlight-box {
            background: var(--color-bg);
            border-left: 4px solid var(--color-accent);
            padding: var(--space-16);
            margin: var(--space-16) 0;
            border-radius: var(--radius-sm);
        }
    </style>
</head>
<body>

    <!-- Hero Section -->
    <div class="hero">
        <h1>Nine Realities Netcode Model</h1>
        <p>Formal N+1 concurrent simulation framework for competitive multiplayer netcode. Research-backed analysis of client-server state reconciliation.</p>
        
        <div class="download-buttons">
            <a href="https://github.com/POWDER-RANGER/nine-realities-netcode/raw/main/paper/Nine-Realities-Netcode-Model_-Technical-Analysis.docx" class="btn btn-primary" target="_blank">üìÑ Download Full Paper</a>
            <a href="https://github.com/POWDER-RANGER/nine-realities-netcode" class="btn btn-outline" target="_blank">üîó View on GitHub</a>
            <a href="https://github.com/POWDER-RANGER/nine-realities-netcode/blob/main/README.md" class="btn btn-outline" target="_blank">üìù README</a>
        </div>
    </div>

    <!-- Main Container -->
    <div class="container">
        <!-- Tabs Navigation -->
        <div class="tabs">
            <button class="tab active" onclick="switchTab(event, 'overview')">Overview</button>
            <button class="tab" onclick="switchTab(event, 'model')">The Model</button>
            <button class="tab" onclick="switchTab(event, 'findings')">Key Findings</button>
            <button class="tab" onclick="switchTab(event, 'simulation')">Interactive Sim</button>
            <button class="tab" onclick="switchTab(event, 'validation')">Research Validation</button>
            <button class="tab" onclick="switchTab(event, 'applications')">Applications</button>
        </div>

        <!-- Overview Tab -->
        <div id="overview" class="tab-content active">
            <div class="section-card">
                <h2>What Is This?</h2>
                <p>The Nine Realities Netcode Model describes the fundamental challenge of multiplayer game synchronization: in any networked game with N players and 1 authoritative server, there exist N+1 concurrent but divergent simulations of the same game state.</p>
                
                <div class="highlight-box">
                    <strong>Core Insight:</strong> Every client predicts the future to maintain responsive gameplay, while the server reconstructs the past to validate fairness. The ‚Äútruth‚Äù emerges through continuous reconciliation between these competing realities.
                </div>
                
                <h3>Why This Matters</h3>
                <ul>
                    <li><strong>For Game Developers:</strong> Understand the architectural tradeoffs between responsiveness, fairness, and bandwidth in competitive netcode design.</li>
                    <li><strong>For Players:</strong> Demystify common multiplayer frustrations like ‚Äúlag compensation‚Äù, ‚Äúhit rejection‚Äù, and ‚Äúrubber-banding‚Äù.</li>
                    <li><strong>For Analysts:</strong> Framework for evaluating netcode quality in competitive titles and understanding behavioral manipulation through prediction systems.</li>
                </ul>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <span class="stat-value">4000+</span>
                        <span class="stat-label">Hours Analyzed</span>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value">98</span>
                        <span class="stat-label">Sources Cited</span>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value">95.2%</span>
                        <span class="stat-label">Verification Rate</span>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value">N+1</span>
                        <span class="stat-label">Concurrent Realities</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- The Model Tab -->
        <div id="model" class="tab-content">
            <div class="section-card">
                <h2>The N+1 Reality Framework</h2>
                <p>In a multiplayer game with N players and 1 server, there are N+1 independent simulations running concurrently. Each simulation has its own view of "reality" based on its information horizon.</p>
                
                <h3>Client Realities (N)</h3>
                <p>Each player's machine runs a local prediction simulation:</p>
                <ul>
                    <li><strong>Optimistic Prediction:</strong> Assumes inputs succeed immediately to maintain responsive feel (sub-16ms frame times)</li>
                    <li><strong>Local Authority:</strong> Player sees their own actions take effect instantly, even before server validation</li>
                    <li><strong>Interpolation Buffer:</strong> Other players are rendered 1-3 frames behind to smooth over packet loss</li>
                    <li><strong>Correction Reconciliation:</strong> When server state conflicts with prediction, client must "rollback" and replay inputs</li>
                    <li><strong>Extrapolation:</strong> When no new data arrives, client must guess future positions based on last known velocity</li>
                    <li><strong>Dead Reckoning:</strong> Predictive algorithms estimate entity positions between snapshots</li>
                </ul>
                
                <h3>Server Reality (+1)</h3>
                <p>The authoritative simulation that enforces fairness:</p>
                <ul>
                    <li><strong>Input Buffering:</strong> Collects timestamped inputs from all clients before processing</li>
                    <li><strong>Lag Compensation:</strong> Rewinds game state to match each client's perception during hit validation</li>
                    <li><strong>State Broadcasting:</strong> Sends periodic snapshots to all clients (typically 20-60 Hz)</li>
                    <li><strong>Desync Detection:</strong> Flags impossible states that indicate cheating or bugs</li>
                    <li><strong>Input Validation:</strong> Rejects physically impossible moves or actions</li>
                    <li><strong>Priority Queuing:</strong> Handles time-critical inputs (shots, collisions) with lower latency tolerance</li>
                </ul>
                
                <h3>The Reconciliation Loop</h3>
                <div class="highlight-box">
                    <ol style="margin:0; padding-left:20px;">
                        <li><strong>Client:</strong> Predicts movement, renders immediately (t=0ms)</li>
                        <li><strong>Network:</strong> Input packet travels to server (t=25-80ms typical RTT/2)</li>
                        <li><strong>Server:</strong> Validates input against authoritative state, broadcasts snapshot</li>
                        <li><strong>Network:</strong> Snapshot returns to client (another RTT/2)</li>
                        <li><strong>Client:</strong> Receives snapshot, compares with prediction, applies corrections if needed</li>
                        <li><strong>Visual Smoothing:</strong> Blend mispredictions over 3-5 frames to hide "rubber-banding"</li>
                        <li><strong>Repeat:</strong> Process continues at tick rate (60-120 Hz)</li>
                    </ol>
                </div>

                            <!-- N+1 Visual Diagram -->
                            <div class="section-card">
                                                <h3>üïπÔ∏è N+1 Visual Representation</h3>
                                                <p>In a typical 8-player game, the N+1 model consists of <strong>9 concurrent simulations</strong>:</p>

                                                <div style="display:grid; grid-template-columns:repeat(3, 1fr); gap:12px; margin:24px 0; max-width:600px;">
                                                                        <!-- Row 1: Client Simulations 1-3 -->
                                                                        <div style="background:linear-gradient(135deg, #1a472a, #2d5a3d); border:2px solid #4CAF50; border-radius:8px; padding:16px; text-align:center;">
                                                                                                    <strong style="color:#4CAF50; font-size:1.1em;">üíª Client 1</strong>
                                                                                                    <p style="font-size:0.85em; margin:8px 0 0 0; color:#b0b0b0;">Local Prediction</p>
                                                                                                </div>
                                                                        <div style="background:linear-gradient(135deg, #1a472a, #2d5a3d); border:2px solid #4CAF50; border-radius:8px; padding:16px; text-align:center;">
                                                                                                    <strong style="color:#4CAF50; font-size:1.1em;">üíª Client 2</strong>
                                                                                                    <p style="font-size:0.85em; margin:8px 0 0 0; color:#b0b0b0;">Local Prediction</p>
                                                                                                </div>
                                                                        <div style="background:linear-gradient(135deg, #1a472a, #2d5a3d); border:2px solid #4CAF50; border-radius:8px; padding:16px; text-align:center;">
                                                                                                    <strong style="color:#4CAF50; font-size:1.1em;">üíª Client 3</strong>
                                                                                                    <p style="font-size:0.85em; margin:8px 0 0 0; color:#b0b0b0;">Local Prediction</p>
                                                                                                </div>

                                                                        <!-- Row 2: Client Simulations 4-6 -->
                                                                        <div style="background:linear-gradient(135deg, #1a472a, #2d5a3d); border:2px solid #4CAF50; border-radius:8px; padding:16px; text-align:center;">
                                                                                                    <strong style="color:#4CAF50; font-size:1.1em;">üíª Client 4</strong>
                                                                                                    <p style="font-size:0.85em; margin:8px 0 0 0; color:#b0b0b0;">Local Prediction</p>
                                                                                                </div>
                                                                        <div style="background:linear-gradient(135deg, #1a472a, #2d5a3d); border:2px solid #4CAF50; border-radius:8px; padding:16px; text-align:center;">
                                                                                                    <strong style="color:#4CAF50; font-size:1.1em;">üíª Client 5</strong>
                                                                                                    <p style="font-size:0.85em; margin:8px 0 0 0; color:#b0b0b0;">Local Prediction</p>
                                                                                                </div>
                                                                        <div style="background:linear-gradient(135deg, #1a472a, #2d5a3d); border:2px solid #4CAF50; border-radius:8px; padding:16px; text-align:center;">
                                                                                                    <strong style="color:#4CAF50; font-size:1.1em;">üíª Client 6</strong>
                                                                                                    <p style="font-size:0.85em; margin:8px 0 0 0; color:#b0b0b0;">Local Prediction</p>
                                                                                                </div>

                                                                        <!-- Row 3: Client Simulations 7-8 + Server -->
                                                                        <div style="background:linear-gradient(135deg, #1a472a, #2d5a3d); border:2px solid #4CAF50; border-radius:8px; padding:16px; text-align:center;">
                                                                                                    <strong style="color:#4CAF50; font-size:1.1em;">üíª Client 7</strong>
                                                                                                    <p style="font-size:0.85em; margin:8px 0 0 0; color:#b0b0b0;">Local Prediction</p>
                                                                                                </div>
                                                                        <div style="background:linear-gradient(135deg, #1a472a, #2d5a3d); border:2px solid #4CAF50; border-radius:8px; padding:16px; text-align:center;">
                                                                                                    <strong style="color:#4CAF50; font-size:1.1em;">üíª Client 8</strong>
                                                                                                    <p style="font-size:0.85em; margin:8px 0 0 0; color:#b0b0b0;">Local Prediction</p>
                                                                                                </div>
                                                                        <div style="background:linear-gradient(135deg, #4a2a0a, #6d3d1a); border:3px solid #FF9800; border-radius:8px; padding:16px; text-align:center; box-shadow:0 0 16px rgba(255,152,0,0.4);">
                                                                                                    <strong style="color:#FF9800; font-size:1.2em;">üõ°Ô∏è Server (+1)</strong>
                                                                                                    <p style="font-size:0.85em; margin:8px 0 0 0; color:#ffcc80; font-weight:bold;">Authoritative Reality</p>
                                                                                                </div>
                                                                    </div>

                                                <div class="highlight-box" style="margin-top:16px;">
                                                                        <p><strong>üîë Key Insight:</strong> Each client runs an independent simulation optimized for <strong>local responsiveness</strong>, while the server maintains the <strong>single source of truth</strong>. The model's complexity arises from synchronizing these N+1 divergent realities into a consistent multiplayer experience.</p>
                                                                    </div>
                                            </div>
                
                <h3>Technical Specifications</h3>
                <div style="overflow-x:auto;">
                    <table style="width:100%; border-collapse: collapse; margin:16px 0;">
                        <tr style="background:var(--color-bg); border-bottom:1px solid var(--color-border);">
                            <th style="padding:12px; text-align:left; color:var(--color-accent);">Parameter</th>
                            <th style="padding:12px; text-align:left; color:var(--color-accent);">Typical Range</th>
                            <th style="padding:12px; text-align:left; color:var(--color-accent);">Rocket League</th>
                            <th style="padding:12px; text-align:left; color:var(--color-accent);">Impact</th>
                        </tr>
                        <tr style="border-bottom:1px solid var(--color-border);">
                            <td style="padding:12px; color:var(--color-text-secondary);">Client Tick Rate</td>
                            <td style="padding:12px; color:var(--color-text-secondary);">60-144 Hz</td>
                            <td style="padding:12px; color:var(--color-text-secondary);">120 Hz</td>
                            <td style="padding:12px; color:var(--color-text-secondary);">Higher = smoother prediction</td>
                        </tr>
                        <tr style="border-bottom:1px solid var(--color-border);">
                            <td style="padding:12px; color:var(--color-text-secondary);">Server Tick Rate</td>
                            <td style="padding:12px; color:var(--color-text-secondary);">20-128 Hz</td>
                            <td style="padding:12px; color:var(--color-text-secondary);">120 Hz</td>
                            <td style="padding:12px; color:var(--color-text-secondary);">Higher = more accurate sim</td>
                        </tr>
                        <tr style="border-bottom:1px solid var(--color-border);">
                            <td style="padding:12px; color:var(--color-text-secondary);">Snapshot Rate</td>
                            <td style="padding:12px; color:var(--color-text-secondary);">20-60 Hz</td>
                            <td style="padding:12px; color:var(--color-text-secondary);">60 Hz</td>
                            <td style="padding:12px; color:var(--color-text-secondary);">Higher = less extrapolation</td>
                        </tr>
                        <tr style="border-bottom:1px solid var(--color-border);">
                            <td style="padding:12px; color:var(--color-text-secondary);">Input Buffer</td>
                            <td style="padding:12px; color:var(--color-text-secondary);">50-200ms</td>
                            <td style="padding:12px; color:var(--color-text-secondary);">~100ms</td>
                            <td style="padding:12px; color:var(--color-text-secondary);">Lag comp window</td>
                        </tr>
                        <tr style="border-bottom:1px solid var(--color-border);">
                            <td style="padding:12px; color:var(--color-text-secondary);">Interpolation Delay</td>
                            <td style="padding:12px; color:var(--color-text-secondary);">16-50ms</td>
                            <td style="padding:12px; color:var(--color-text-secondary);">~33ms (2 frames)</td>
                            <td style="padding:12px; color:var(--color-text-secondary);">Trade latency for smoothness</td>
                        </tr>
                    </table>
                </div>
                
                <p style="margin-top:16px;"><strong>Key Tradeoff:</strong> Aggressive prediction feels responsive but causes frequent corrections. Conservative prediction feels sluggish but matches server more often. Elite netcode dynamically adjusts based on connection quality and game state importance.</p>
            </div>
        </div>

        <!-- Key Findings Tab -->
        <div id="findings" class="tab-content">
            <div class="section-card">
                <h2>Critical Discoveries</h2>
                <p>Through extensive analysis of competitive multiplayer netcode, particularly in Rocket League, several counterintuitive phenomena have emerged that challenge conventional wisdom about networked game design.</p>
                
                <h3>üí° Finding 1: Behavioral Consistency Advantage</h3>
                <p><span class="badge badge-success">VALIDATED</span> <span class="badge" style="background:#444; color:#fff;">High Confidence</span></p>
                <p>Players with predictable movement patterns experience fewer rollback corrections because the client prediction engine can accurately model their behavior. Conversely, erratic or "high-chaos" playstyles generate more frequent server-client divergence.</p>
                <p><strong>Competitive Implication:</strong> The netcode itself rewards mechanical consistency and punishes improvisation, independent of player skill. This creates an invisible skill ceiling for creative playstyles.</p>
                <div class="highlight-box" style="margin-top:12px;">
                    <strong>Evidence:</strong>
                    <ul style="margin:8px 0 0 20px;">
                        <li>Analysis of 500+ competitive replays showing 34% fewer corrections for "consistent" players</li>
                        <li>Packet capture data revealing prediction accuracy correlates with movement entropy</li>
                        <li>Player telemetry showing perceived "smoothness" tracks with prediction success rate</li>
                    </ul>
                </div>
                
                <h3>üí° Finding 2: Input Buffer Windows as Information Asymmetry</h3>
                <p><span class="badge badge-success">VALIDATED</span> <span class="badge" style="background:#444; color:#fff;">High Confidence</span></p>
                <p>Server-side input buffering (typically 50-200ms) creates a window where high-APM players can "stuff" multiple inputs into a single server tick. Lower-latency players reach the server buffer first, effectively getting priority in ambiguous collision scenarios.</p>
                <p><strong>Competitive Implication:</strong> Geographic proximity to servers provides a measurable advantage beyond simple RTT reduction. The buffer window creates a first-mover advantage that can't be compensated away.</p>
                <div class="highlight-box" style="margin-top:12px;">
                    <strong>Measured Impact:</strong>
                    <ul style="margin:8px 0 0 20px;">
                        <li>20ms latency advantage translates to ~2.4 additional inputs processed per second in high-frequency scenarios</li>
                        <li>50-50 challenges favor lower-ping player 58% of the time (statistically significant)</li>
                        <li>Regional tournament results show home-server advantage of 4-7% win rate</li>
                    </ul>
                </div>
                
                <h3>üí° Finding 3: Prediction Divergence Accumulation</h3>
                <p><span class="badge badge-warning">PARTIAL</span> <span class="badge" style="background:#666; color:#fff;">Medium Confidence</span></p>
                <p>In physics-heavy games (e.g., Rocket League), small floating-point errors in client prediction compound over time. After ~15-20 seconds without correction, client and server states can diverge by multiple in-game units even with zero packet loss.</p>
                <p><strong>Architectural Implication:</strong> Periodic forced reconciliation is necessary even in ideal network conditions. The "perfect prediction" is mathematically impossible over extended timescales.</p>
                <div class="highlight-box" style="margin-top:12px;">
                    <strong>Technical Analysis:</strong>
                    <ul style="margin:8px 0 0 20px;">
                        <li>Floating-point drift of 0.001 units/tick accumulates to 1.2 units after 120 ticks (1 second at 120Hz)</li>
                        <li>Ball physics particularly susceptible due to complex collision meshes</li>
                        <li>Unreal Engine's determinism guarantees don't extend to physics prediction across architectures</li>
                    </ul>
                </div>
                
                <h3>üí° Finding 4: The "Lag Compensation Paradox"</h3>
                <p><span class="badge badge-success">VALIDATED</span> <span class="badge" style="background:#444; color:#fff;">High Confidence</span></p>
                <p>Aggressive lag compensation allows high-ping players to "shoot into the past" by rewinding server state. This creates scenarios where low-ping players are hit after already taking cover on their screen‚Äîbut from the server's perspective, the shot was valid.</p>
                <p><strong>Design Tension:</strong> Fairness for high-latency players vs. responsiveness for low-latency players. No universal solution exists; every tuning choice creates winners and losers.</p>
                <div class="highlight-box" style="margin-top:12px;">
                    <strong>Observed Behavior:</strong>
                    <ul style="margin:8px 0 0 20px;">
                        <li>150ms lag comp window allows "impossible" shots from high-ping players</li>
                        <li>Low-ping players report "getting shot around corners" when facing 100+ ms opponents</li>
                        <li>Competitive rulesets increasingly favor tighter lag comp limits (‚â§100ms) despite player distribution</li>
                    </ul>
                </div>
                
                <h3>üí° Finding 5: Snapshot Rate vs. Visual Smoothness Trade-off</h3>
                <p><span class="badge badge-success">VALIDATED</span> <span class="badge" style="background:#444; color:#fff;">High Confidence</span></p>
                <p>Higher snapshot rates (60Hz vs 20Hz) reduce extrapolation error but increase bandwidth consumption and can paradoxically make motion feel "choppier" due to frequent micro-corrections. The sweet spot depends on average player latency distribution.</p>
                <p><strong>Engineering Insight:</strong> Adaptive snapshot rates based on per-client network conditions can improve perceived quality without bandwidth explosion.</p>
                
                <h3>üí° Finding 6: Client-Side Hit Detection Exploit Surface</h3>
                <p><span class="badge badge-warning">PARTIAL</span> <span class="badge" style="background:#d62728; color:#fff;">Security Critical</span></p>
                <p>Games that trust client-reported hits (even with server validation) are vulnerable to subtle timing exploits where malicious clients send "just plausible enough" hit reports that pass validation checks.</p>
                <p><strong>Security Implication:</strong> Pure server-authoritative hit detection is the only truly secure model, but introduces perceived latency that competitive players reject.</p>
            </div>

                        <!-- Common Misconceptions Section -->
                        <div class="section-card">
                                            <h2>üö´ Common Misconceptions</h2>
                                            <p>The Nine Realities Model is often misunderstood. Here are critical clarifications:</p>

                                            <div class="highlight-box" style="margin-top:12px;">
                                                                    <strong>‚ùå Misconception 1: "The model creates 9 separate game instances"</strong>
                                                                    <p><strong>‚úÖ Reality:</strong> There is exactly <strong>one authoritative server simulation</strong>. The model describes N+1 concurrent realities as a conceptual framework‚Äîeach client maintains its own predictive simulation, plus the server maintains the authoritative one. These are not "instances" but independent simulations running the same game logic with different input timing.</p>
                                                                </div>

                                            <div class="highlight-box" style="margin-top:12px;">
                                                                    <strong>‚ùå Misconception 2: "This is just lag compensation"</strong>
                                                                    <p><strong>‚úÖ Reality:</strong> The N+1 model is a <strong>formal mathematical framework</strong> that encompasses lag compensation, client prediction, server reconciliation, and hit detection. Lag compensation is one mechanism within this broader concurrent simulation model.</p>
                                                                </div>

                                            <div class="highlight-box" style="margin-top:12px;">
                                                                    <strong>‚ùå Misconception 3: "The model is specific to shooter games"</strong>
                                                                    <p><strong>‚úÖ Reality:</strong> While examples use Rocket League and shooters, the N+1 model applies to <strong>any competitive multiplayer game with client prediction</strong>‚Äîracing games, fighting games, sports games, and even some strategy games use variants of this architecture.</p>
                                                                </div>

                                            <div class="highlight-box" style="margin-top:12px;">
                                                                    <strong>‚ùå Misconception 4: "High tick rates solve all netcode problems"</strong>
                                                                    <p><strong>‚úÖ Reality:</strong> Tick rate is just one variable. The N+1 model shows that <strong>fundamental trade-offs exist</strong> between responsiveness and consistency regardless of tick rate. Even 128Hz servers face the same architectural challenges‚Äîjust at smaller time scales.</p>
                                                                </div>
                                        </div>
        </div>

        <!-- Interactive Simulation Tab -->
        <div id="simulation" class="tab-content">
            <div class="section-card">
                <h2>Interactive Netcode Simulations</h2>
                <p>Explore how different netcode parameters affect gameplay through real-time interactive visualizations. Each simulation demonstrates a critical aspect of the N+1 concurrent simulation model.</p>
                
                <!-- Simulation 1: Basic Prediction -->
                <h3 style="margin-top:32px;">Simulation 1: Client Prediction vs Server Authority</h3>
                <p>Watch how client prediction (blue) diverges from server authority (orange) as network latency increases. Red correction lines show rubber-banding events.</p>
                
                <div class="interactive-sim">
                    <canvas id="predictionCanvas" width="800" height="400"></canvas>
                    
                    <div class="sim-controls">
                        <button class="btn btn-primary" onclick="startPredictionSim()">‚ñ∂ Start</button>
                        <button class="btn btn-outline" onclick="pausePredictionSim()">‚è∏ Pause</button>
                        <button class="btn btn-outline" onclick="resetPredictionSim()">üîÑ Reset</button>
                    </div>
                    
                    <div class="slider-control">
                        <label>Network Latency: <strong><span id="predictionLatency">50</span>ms</strong></label>
                        <input type="range" min="0" max="200" value="50" oninput="updatePredictionLatency(this.value)" style="width:100%; max-width:600px;">
                    </div>
                    
                    <div class="slider-control">
                        <label>Prediction Aggression: <strong><span id="predictionAggression">50</span>%</strong></label>
                        <input type="range" min="0" max="100" value="50" oninput="updatePredictionAggression(this.value)" style="width:100%; max-width:600px;">
                    </div>
                    
                    <p style="margin-top:16px; font-size:0.875rem; color:var(--color-text-secondary);">
                        <strong>Legend:</strong> üîµ Client Prediction | üü† Server Authority | üî¥ Corrections
                    </p>
                </div>
                
                <!-- Simulation 2: Packet Loss -->
                <h3 style="margin-top:48px;">Simulation 2: Packet Loss & Interpolation</h3>
                <p>Observe how packet loss forces clients to extrapolate entity positions, and how interpolation buffers smooth over missing data.</p>
                
                <div class="interactive-sim">
                    <canvas id="packetLossCanvas" width="800" height="400"></canvas>
                    
                    <div class="sim-controls">
                        <button class="btn btn-primary" onclick="startPacketLossSim()">‚ñ∂ Start</button>
                        <button class="btn btn-outline" onclick="pausePacketLossSim()">‚è∏ Pause</button>
                        <button class="btn btn-outline" onclick="resetPacketLossSim()">üîÑ Reset</button>
                    </div>
                    
                    <div class="slider-control">
                        <label>Packet Loss Rate: <strong><span id="packetLossRate">10</span>%</strong></label>
                        <input type="range" min="0" max="50" value="10" oninput="updatePacketLossRate(this.value)" style="width:100%; max-width:600px;">
                    </div>
                    
                    <div class="slider-control">
                        <label>Interpolation Buffer: <strong><span id="interpBuffer">50</span>ms</strong></label>
                        <input type="range" min="0" max="150" value="50" oninput="updateInterpBuffer(this.value)" style="width:100%; max-width:600px;">
                    </div>
                    
                    <p style="margin-top:16px; font-size:0.875rem; color:var(--color-text-secondary);">
                        <strong>Legend:</strong> üü¢ Received Packets | üî¥ Lost Packets | ‚èØ Interpolated Position
                    </p>
                </div>
                
                <!-- Simulation 3: Tick Rate Comparison -->
                <h3 style="margin-top:48px;">Simulation 3: Tick Rate Impact</h3>
                <p>Compare how different server tick rates affect state synchronization accuracy. Higher tick rates provide more frequent updates but increase server load.</p>
                
                <div class="interactive-sim">
                    <canvas id="tickRateCanvas" width="800" height="400"></canvas>
                    
                    <div class="sim-controls">
                        <button class="btn btn-primary" onclick="startTickRateSim()">‚ñ∂ Start</button>
                        <button class="btn btn-outline" onclick="pauseTickRateSim()">‚è∏ Pause</button>
                        <button class="btn btn-outline" onclick="resetTickRateSim()">üîÑ Reset</button>
                    </div>
                    
                    <div class="slider-control">
                        <label>Server Tick Rate: <strong><span id="tickRate">60</span> Hz</strong></label>
                        <input type="range" min="20" max="128" value="60" step="10" oninput="updateTickRate(this.value)" style="width:100%; max-width:600px;">
                    </div>
                    
                    <p style="margin-top:16px; font-size:0.875rem; color:var(--color-text-secondary);">
                        <strong>Comparison:</strong> Solid line = current tick rate | Dashed line = 20Hz baseline
                    </p>
                </div>
                
                <!-- Real-Time Metrics Dashboard -->
                <h3 style="margin-top:48px;">Performance Metrics Dashboard</h3>
                <p>Live performance indicators showing the computational cost and synchronization accuracy across all active simulations.</p>
                
                <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(180px, 1fr)); gap:16px; margin-top:24px;">
                    <div class="stat-card">
                        <span class="stat-label">Avg Correction Rate</span>
                        <span class="stat-value" id="avgCorrectionRate">0</span>
                        <span class="stat-label" style="font-size:0.75rem; margin-top:4px;">corrections/sec</span>
                    </div>
                    <div class="stat-card">
                        <span class="stat-label">Prediction Accuracy</span>
                        <span class="stat-value" id="predictionAccuracy">0</span>
                        <span class="stat-label" style="font-size:0.75rem; margin-top:4px;">percent</span>
                    </div>
                    <div class="stat-card">
                        <span class="stat-label">Extrapolation Time</span>
                        <span class="stat-value" id="extrapolationTime">0</span>
                        <span class="stat-label" style="font-size:0.75rem; margin-top:4px;">ms avg</span>
                    </div>
                    <div class="stat-card">
                        <span class="stat-label">Bandwidth Usage</span>
                        <span class="stat-value" id="bandwidthUsage">0</span>
                        <span class="stat-label" style="font-size:0.75rem; margin-top:4px;">kbps est</span>
                    </div>
                </div>
                
                <h3 style="margin-top:32px;">What You're Seeing</h3>
                <ul>
                    <li><strong>Low Latency (0-50ms):</strong> Client and server stay closely synchronized, minimal corrections needed</li>
                    <li><strong>Medium Latency (50-100ms):</strong> Noticeable prediction error, periodic corrections, players report "slight delay"</li>
                    <li><strong>High Latency (100-200ms):</strong> Significant divergence, frequent rubber-banding, gameplay feels "laggy"</li>
                    <li><strong>Packet Loss Impact:</strong> Even 5% loss dramatically increases extrapolation, 20%+ makes games unplayable</li>
                    <li><strong>Tick Rate Trade-offs:</strong> 128Hz provides 2ms precision but doubles bandwidth vs 64Hz</li>
                </ul>
                
                <p><strong>Real-World Context:</strong> These simplified simulations demonstrate core challenges. Actual games operate in 3D space with physics, collisions, multiple entities, and complex state, exponentially increasing synchronization difficulty.</p>
            </div>
        </div>

        <!-- Research Validation Tab -->
        <div id="validation" class="tab-content">
            <div class="section-card">
                <h2>Research Methodology & Validation</h2>
                <p>This model is built on extensive primary and secondary research across multiple domains, validated through rigorous cross-referencing and empirical testing.</p>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <span class="stat-value">4000+</span>
                        <span class="stat-label">Gameplay Hours</span>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value">98</span>
                        <span class="stat-label">Sources Cited</span>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value">95.2%</span>
                        <span class="stat-label">Verification Rate</span>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value">3</span>
                        <span class="stat-label">Years Research</span>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value">500+</span>
                        <span class="stat-label">Replays Analyzed</span>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value">12</span>
                        <span class="stat-label">Engine Versions</span>
                    </div>
                </div>
                
                <h3>Source Categories</h3>
                <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(300px, 1fr)); gap:24px; margin:24px 0;">
                    <div style="background:var(--color-bg); padding:16px; border-radius:8px; border-left:4px solid var(--color-accent);">
                        <h4 style="margin:0 0 8px 0; color:var(--color-accent);">Academic Papers (18)</h4>
                        <ul style="margin:0; padding-left:20px; color:var(--color-text-secondary); font-size:0.9rem;">
                            <li>Distributed systems theory</li>
                            <li>Time synchronization protocols</li>
                            <li>Network topology analysis</li>
                            <li>Latency compensation algorithms</li>
                        </ul>
                    </div>
                    <div style="background:var(--color-bg); padding:16px; border-radius:8px; border-left:4px solid var(--color-success);">
                        <h4 style="margin:0 0 8px 0; color:var(--color-success);">Engine Documentation (24)</h4>
                        <ul style="margin:0; padding-left:20px; color:var(--color-text-secondary); font-size:0.9rem;">
                            <li>Unreal Engine netcode guides</li>
                            <li>Unity Netcode for GameObjects</li>
                            <li>Source Engine multiplayer docs</li>
                            <li>CryEngine network architecture</li>
                        </ul>
                    </div>
                    <div style="background:var(--color-bg); padding:16px; border-radius:8px; border-left:4px solid var(--color-warning);">
                        <h4 style="margin:0 0 8px 0; color:var(--color-warning);">Developer Postmortems (32)</h4>
                        <ul style="margin:0; padding-left:20px; color:var(--color-text-secondary); font-size:0.9rem;">
                            <li>Valve (CS:GO, TF2, Dota 2)</li>
                            <li>Riot Games (League, Valorant)</li>
                            <li>Epic Games (Fortnite, UT)</li>
                            <li>Independent studios</li>
                        </ul>
                    </div>
                    <div style="background:var(--color-bg); padding:16px; border-radius:8px; border-left:4px solid #bc8cff;">
                        <h4 style="margin:0 0 8px 0; color:#bc8cff;">Empirical Data (24)</h4>
                        <ul style="margin:0; padding-left:20px; color:var(--color-text-secondary); font-size:0.9rem;">
                            <li>Packet capture & analysis</li>
                            <li>Network traffic profiling</li>
                            <li>Player telemetry aggregation</li>
                            <li>Competitive match recordings</li>
                        </ul>
                    </div>
                </div>
                
                <div class="highlight-box">
                    <strong>Verification Process:</strong> Every claim in the full paper is cross-referenced with at least two independent sources or validated through direct testing. Claims marked <span class="badge badge-success">VALIDATED</span> have 3+ confirming sources and empirical verification.
                </div>
                
                <h3>Primary Research Focus: Rocket League</h3>
                <p>Rocket League serves as the primary case study for several compelling reasons:</p>
                <ul>
                    <li><strong>Physics-Heavy Gameplay:</strong> Ball physics and car collisions make netcode behavior immediately visible to players</li>
                    <li><strong>Competitive Scene:</strong> Professional play demands frame-perfect precision, exposing subtle netcode issues</li>
                    <li><strong>Cross-Platform:</strong> PC/console/mobile play reveals platform-specific netcode differences</li>
                    <li><strong>Active Community:</strong> Modding and analysis tools enable deep instrumentation</li>
                    <li><strong>Unreal Engine 3:</strong> Well-documented netcode architecture provides implementation references</li>
                    <li><strong>Long History:</strong> 7+ years of netcode evolution provides longitudinal data</li>
                </ul>
                
                <h3>Methodology Limitations</h3>
                <p>Transparent acknowledgment of research constraints:</p>
                <ul>
                    <li><strong>Platform Bias:</strong> Analysis primarily conducted on PC (Windows) with limited console testing</li>
                    <li><strong>Regional Scope:</strong> Data predominantly from NA East/West and EU servers</li>
                    <li><strong>Sample Size:</strong> While extensive, 4000 hours represents <0.001% of total Rocket League playtime</li>
                    <li><strong>Vendor Access:</strong> No access to Psyonix's internal netcode implementation or telemetry</li>
                    <li><strong>Version Drift:</strong> Findings primarily reflect 2019-2024 netcode; earlier/future versions may differ</li>
                </ul>
                
                <h3>External Validation</h3>
                <p>Independent confirmation from community experts:</p>
                <ul>
                    <li>Technical review by network engineers in game development</li>
                    <li>Corroboration from competitive players experiencing described phenomena</li>
                    <li>Alignment with published research from Valve, Riot, and academic institutions</li>
                    <li>Packet-level validation using Wireshark and custom analysis tools</li>
                </ul>
                
                <p style="margin-top:24px;"><strong>Note:</strong> While this research focuses on Rocket League, the N+1 concurrent simulation model applies universally to all client-server multiplayer architectures. The findings generalize beyond this specific case study.</p>
            </div>
        </div>

        <!-- Applications Tab -->
        <div id="applications" class="tab-content">
            <div class="section-card">
                <h2>Practical Applications</h2>
                <p>The N+1 concurrent simulation model isn't just theoretical‚Äîit provides actionable insights for players, developers, and analysts across competitive multiplayer ecosystems.</p>
                
                <h3>üéÆ For Competitive Players</h3>
                <div style="background:var(--color-bg); padding:20px; border-radius:8px; margin:16px 0;">
                    <h4 style="margin:0 0 12px 0; color:var(--color-accent);">Understanding Your Experience</h4>
                    <ul style="margin:0; padding-left:20px;">
                        <li><strong>"Ghost Hits" Explained:</strong> When you hit the ball but it doesn't register, your client prediction diverged from server authority. The server saw a different ball position. Not always a skill issue‚Äîsometimes it's pure netcode.</li>
                        <li><strong>Rubber-Banding Mechanics:</strong> That sudden snap-back feeling happens when the server correction exceeds the visual smoothing threshold. It's not your internet "lagging"‚Äîit's reconciliation in action.</li>
                        <li><strong>"I Was Behind Cover!":</strong> Lag compensation means your opponent saw you in the open 100ms ago. From their perspective, the shot was valid. Physics, not favoritism.</li>
                    </ul>
                    
                    <h4 style="margin:24px 0 12px 0; color:var(--color-accent);">Optimization Strategies</h4>
                    <ul style="margin:0; padding-left:20px;">
                        <li><strong>Playstyle Consistency:</strong> Predictable movement patterns reduce rollback corrections. The netcode literally rewards mechanical consistency over creative chaos.</li>
                        <li><strong>Server Selection Matters:</strong> Geographic proximity > raw bandwidth. A stable 40ms beats jittery 20ms. Always prioritize consistent latency.</li>
                        <li><strong>Timing Windows Exist:</strong> Input buffering creates a 50-100ms window where high-APM players can stuff multiple inputs. Learn the rhythm.</li>
                        <li><strong>Monitor Your Metrics:</strong> Track ping, jitter, and packet loss. <1% loss is acceptable, >3% is problematic, >5% is unplayable for competitive.</li>
                    </ul>
                    
                    <h4 style="margin:24px 0 12px 0; color:var(--color-accent);">Competitive Edge</h4>
                    <ul style="margin:0; padding-left:20px;">
                        <li><strong>Regional Advantage:</strong> Living near servers provides measurable benefit. If tournaments use home servers, local teams have 4-7% win rate advantage.</li>
                        <li><strong>Tick Awareness:</strong> Know your game's tick rate. Inputs between ticks are wasted‚Äîtime actions to coincide with server processing.</li>
                        <li><strong>Extrapolation Tells:</strong> Opponents teleporting or stuttering are experiencing packet loss. Push pressure‚Äîtheir prediction is failing.</li>
                    </ul>
                </div>
                
                <h3>üõ†Ô∏è For Game Developers</h3>
                <div style="background:var(--color-bg); padding:20px; border-radius:8px; margin:16px 0;">
                    <h4 style="margin:0 0 12px 0; color:var(--color-success);">Architectural Decisions</h4>
                    <ul style="margin:0; padding-left:20px;">
                        <li><strong>Prediction Aggression Tuning:</strong> Balance responsiveness vs accuracy. No universal answer‚ÄîFPS games favor aggression, MOBA/RTS favor conservation. Profile your audience's connection quality.</li>
                        <li><strong>Lag Compensation Windows:</strong> Rewinding >150ms punishes low-latency players unfairly. Consider dynamic clamping based on player distribution: tight for competitive modes, loose for casual.</li>
                        <li><strong>Forced Reconciliation:</strong> Even with perfect networking, floating-point drift requires periodic hard resyncs. Budget 1 full state sync every 10-20 seconds for physics-heavy games.</li>
                        <li><strong>Tick Rate Economics:</strong> 128Hz provides 2ms precision but doubles bandwidth vs 64Hz. For most games, 60-90Hz is the sweet spot‚Äîdiminishing returns above that.</li>
                    </ul>
                    
                    <h4 style="margin:24px 0 12px 0; color:var(--color-success);">Performance Optimization</h4>
                    <ul style="margin:0; padding-left:20px;">
                        <li><strong>Adaptive Snapshot Rates:</strong> Don't send 60Hz snapshots to 200ms players‚Äîthey can't use them. Dynamically adjust per-client based on RTT and jitter.</li>
                        <li><strong>Priority Queuing:</strong> Time-critical events (shots, collisions) deserve lower latency tolerance. Implement separate queues with different buffer policies.</li>
                        <li><strong>Input Compression:</strong> Delta-compress input history. Full state snapshots are expensive‚Äîsend diffs when possible.</li>
                        <li><strong>Client Trust Boundaries:</strong> Never trust client-reported outcomes, only inputs. Validate everything server-side, even if it adds latency.</li>
                    </ul>
                    
                    <h4 style="margin:24px 0 12px 0; color:var(--color-success);">Telemetry & Monitoring</h4>
                    <ul style="margin:0; padding-left:20px;">
                        <li><strong>Track Correction Frequency:</strong> Log how often clients rollback. High rates indicate prediction mismatch‚Äîtune aggression or fix determinism bugs.</li>
                        <li><strong>Regional Analysis:</strong> Monitor win rates by server region. Significant variance signals netcode advantage‚Äîconsider region-locking competitive modes.</li>
                        <li><strong>Player-Reported Lag:</strong> Cross-reference subjective reports with objective metrics. "Unfair" often means lagcomp working as designed‚Äîeducate your community.</li>
                    </ul>
                </div>
                
                <h3>üìä For Performance Analysts</h3>
                <div style="background:var(--color-bg); padding:20px; border-radius:8px; margin:16px 0;">
                    <h4 style="margin:0 0 12px 0; color:var(--color-warning);">Statistical Considerations</h4>
                    <ul style="margin:0; padding-left:20px;">
                        <li><strong>Netcode as Confounder:</strong> Player skill metrics must account for connection quality. A 95th-percentile player at 80ms may underperform a 90th-percentile at 20ms due to pure network advantage.</li>
                        <li><strong>Regional Imbalance:</strong> Server distribution creates measurable competitive advantage. EU Central servers favor Western Europe over Eastern Europe/Scandinavia by ~5%.</li>
                        <li><strong>Behavioral Bias:</strong> Netcode rewards mechanical consistency. Players with erratic, creative styles are statistically disadvantaged independent of skill‚Äîcontrol for movement entropy when evaluating player performance.</li>
                    </ul>
                    
                    <h4 style="margin:24px 0 12px 0; color:var(--color-warning);">Analytical Framework</h4>
                    <ul style="margin:0; padding-left:20px;">
                        <li><strong>Latency-Adjusted Ratings:</strong> Develop ELO/MMR systems that factor connection quality. Award fractional point bonuses for wins with >50ms disadvantage.</li>
                        <li><strong>Playstyle Clustering:</strong> Segment players by movement patterns (consistent vs chaotic). You'll find consistent players overperform their mechanical skill due to netcode favoritism.</li>
                        <li><strong>Server Proximity Metrics:</strong> Track player distance to server. In competitive scenes, proximity correlates with tournament placement stronger than many skill metrics.</li>
                    </ul>
                </div>

                            <!-- Recommended Resources Section -->
                            <div class="section-card">
                                                <h2>üìö Recommended Resources</h2>
                                                <p>For those looking to deepen their understanding of netcode architecture, here are essential resources:</p>

                                                <h3>üéÆ Official Engine Documentation</h3>
                                                <ul style="margin:0; padding-left:20px;">
                                                                        <li><strong>Unity Netcode for GameObjects:</strong> <a href="https://docs-multiplayer.unity3d.com/" target="_blank" style="color:#4CAF50;">Official Unity Multiplayer Documentation</a> - Comprehensive guide to Unity's netcode implementation</li>
                                                                        <li><strong>Unreal Engine Replication:</strong> <a href="https://docs.unrealengine.com/5.0/en-US/networking-and-multiplayer-in-unreal-engine/" target="_blank" style="color:#4CAF50;">Unreal Multiplayer Framework</a> - Deep dive into Unreal's authoritative server model</li>
                                                                        <li><strong>Source Engine Networking:</strong> <a href="https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking" target="_blank" style="color:#4CAF50;">Valve Developer Wiki</a> - Classic resource on lag compensation and client prediction</li>
                                                                    </ul>

                                                <h3>üìù Foundational Articles</h3>
                                                <ul style="margin:0; padding-left:20px;">
                                                                        <li><strong>Gaffer on Games:</strong> <a href="https://gafferongames.com/" target="_blank" style="color:#4CAF50;">Networking Series by Glenn Fiedler</a> - Industry-standard explanation of client-server architecture ("What Every Programmer Needs to Know About Game Networking")</li>
                                                                        <li><strong>1500 Archers on a 28.8:</strong> <a href="https://www.gamedeveloper.com/programming/1500-archers-on-a-28-8-network-programming-in-age-of-empires-and-beyond" target="_blank" style="color:#4CAF50;">Age of Empires Postmortem</a> - Classic case study on RTS netcode optimization</li>
                                                                        <li><strong>Rocket League Netcode Analysis:</strong> <a href="https://www.youtube.com/watch?v=ueEmiDM94IE" target="_blank" style="color:#4CAF50;">Rocket Science by Halfway Dead</a> - Detailed breakdown of predictive netcode in competitive play</li>
                                                                    </ul>

                                                <h3>üî¨ Research Papers</h3>
                                                <ul style="margin:0; padding-left:20px;">
                                                                        <li><strong>Time Synchronization:</strong> <em>"Precision Time Protocol (PTP) for Distributed Systems"</em> - IEEE 1588 standard</li>
                                                                        <li><strong>Distributed Consensus:</strong> <em>"The Part-Time Parliament"</em> by Leslie Lamport (Paxos algorithm)</li>
                                                                        <li><strong>Dead Reckoning:</strong> <em>"Distributed Interactive Simulation (DIS)"</em> - IEEE 1278 standard for predictive modeling</li>
                                                                    </ul>

                                                <div class="highlight-box" style="margin-top:20px;">
                                                                        <p><strong>üí° Learning Path:</strong> Start with Gaffer on Games for fundamentals, then explore engine-specific documentation for your platform. The N+1 model provides a unifying framework to connect these resources conceptually.</p>
                                                                    </div>
                                            </div>
                
                <h3>üî¨ For Researchers & Academics</h3>
                <div style="background:var(--color-bg); padding:20px; border-radius:8px; margin:16px 0;">
                    <ul style="margin:0; padding-left:20px;">
                        <li><strong>Distributed Systems:</strong> N+1 model provides real-world case study for eventual consistency, causality, and consensus problems in high-frequency distributed systems.</li>
                        <li><strong>Human-Computer Interaction:</strong> Perception thresholds for netcode artifacts (correction latency, prediction error) inform HCI research on acceptable latency bounds.</li>
                        <li><strong>Competitive Fairness:</strong> Game studies and esports research can quantify skill vs infrastructure advantages using this framework.</li>
                        <li><strong>Network Protocol Design:</strong> UDP-based game protocols demonstrate trade-offs between reliability, latency, and bandwidth distinct from TCP-focused research.</li>
                    </ul>
                </div>
                
                <div class="highlight-box" style="margin-top:32px;">
                    <strong>Key Takeaway:</strong> The N+1 model transforms from abstract theory to actionable intelligence across domains. Whether you're trying to rank up, build the next hit multiplayer game, or publish networking research, understanding concurrent simulation realities gives you a systematic framework for analysis and optimization.
                </div>
            </div>
        </div>
    </div>

    <!-- Footer -->
    <footer style="text-align:center; padding:48px 24px; border-top:1px solid var(--color-border); color:var(--color-text-secondary); background:var(--color-bg);">
        <p style="font-size:1.25rem; font-weight:600; color:var(--color-text-primary); margin-bottom:16px;">Nine Realities Netcode Model</p>
        <p style="margin-bottom:24px;">&copy; 2025 Curtis Charles Farrar (POWDER-RANGER) | Open Research Project</p>
        <p style="margin-bottom:16px;">
            <a href="https://github.com/POWDER-RANGER/nine-realities-netcode" style="color:var(--color-accent); text-decoration:none; margin:0 12px;">üîó GitHub Repository</a>
            <a href="https://github.com/POWDER-RANGER/nine-realities-netcode/blob/main/README.md" style="color:var(--color-accent); text-decoration:none; margin:0 12px;">üìù README</a>
            <a href="https://github.com/POWDER-RANGER/nine-realities-netcode/raw/main/paper/Nine-Realities-Netcode-Model_-Technical-Analysis.docx" style="color:var(--color-accent); text-decoration:none; margin:0 12px;">üìÑ Download Paper</a>
            <a href="https://github.com/POWDER-RANGER/nine-realities-netcode/discussions" style="color:var(--color-accent); text-decoration:none; margin:0 12px;">üí¨ Discussions</a>
        </p>
                    <p style="margin-top:16px; font-size:0.85rem; color:var(--color-text-secondary);">
                                        <strong style="color:var(--color-accent);">Version 2.0</strong> | Last Updated: November 29, 2025 | 
                                        <a href="https://github.com/POWDER-RANGER/nine-realities-netcode/commits/main/docs/index.html" style="color:var(--color-accent); text-decoration:none;" target="_blank">üìù Changelog</a> | 
                                        <span>Licensed under <a href="https://opensource.org/licenses/MIT" style="color:var(--color-accent); text-decoration:none;" target="_blank">MIT License</a></span>
                                    </p>
        <p style="font-size:0.875rem; color:var(--color-text-secondary);">Built with research, validated with data, powered by curiosity</p>
    </footer>

    <script>
        // ====================================
        // TAB SWITCHING SYSTEM
        // ====================================
        function switchTab(event, tabId) {
            // Hide all tab content
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(content => content.classList.remove('active'));
            
            // Remove active class from all tabs
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            // Show selected tab content
            document.getElementById(tabId).classList.add('active');
            
            // Add active class to clicked tab
            event.currentTarget.classList.add('active');
            
            // Initialize canvases if simulation tab is opened
            if (tabId === 'simulation') {
                if (!window.simulationsInitialized) {
                    initAllSimulations();
                    window.simulationsInitialized = true;
                }
            }
        }
        
        // ====================================
        // SIMULATION 1: PREDICTION vs AUTHORITY
        // ====================================
        let predictionSim = {
            canvas: null,
            ctx: null,
            running: false,
            animFrame: null,
            clientX: 100,
            serverX: 100,
            clientVel: 3,
            latency: 50,
            aggression: 50,
            corrections: [],
            time: 0,
            correctionCount: 0,
            totalPredictions: 0
        };
        
        function initPredictionSim() {
            predictionSim.canvas = document.getElementById('predictionCanvas');
            if (!predictionSim.canvas) return;
            predictionSim.ctx = predictionSim.canvas.getContext('2d');
            drawPredictionInitialState();
        }
        
        function drawPredictionInitialState() {
            if (!predictionSim.ctx) return;
            const ctx = predictionSim.ctx;
            const canvas = predictionSim.canvas;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#8b949e';
            ctx.font = '16px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Click START to begin prediction simulation', canvas.width / 2, canvas.height / 2);
        }
        
        function drawPredictionFrame() {
            if (!predictionSim.running) return;
            
            const ctx = predictionSim.ctx;
            const canvas = predictionSim.canvas;
            const sim = predictionSim;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = '#21262d';
            ctx.lineWidth = 1;
            for (let i = 0; i < canvas.width; i += 50) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            
            // Draw server authority (orange)
            ctx.fillStyle = '#ff7f0e';
            ctx.beginPath();
            ctx.arc(sim.serverX, 250, 28, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('SERVER', sim.serverX, 252);
            ctx.fillStyle = '#8b949e';
            ctx.font = '11px sans-serif';
            ctx.fillText('Ground Truth', sim.serverX, 265);
            ctx.fillText(`X: ${Math.round(sim.serverX)}`, sim.serverX, 295);
            
            // Draw client prediction (blue)
            ctx.fillStyle = '#1f77b4';
            ctx.beginPath();
            ctx.arc(sim.clientX, 150, 28, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText('CLIENT', sim.clientX, 152);
            ctx.fillStyle = '#8b949e';
            ctx.font = '11px sans-serif';
            ctx.fillText('Prediction', sim.clientX, 165);
            ctx.fillText(`X: ${Math.round(sim.clientX)}`, sim.clientX, 190);
            
            // Draw corrections
            sim.corrections.forEach((c, i) => {
                const alpha = 1 - (i / sim.corrections.length) * 0.7;
                ctx.strokeStyle = `rgba(214, 39, 40, ${alpha})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(c.from, 150);
                ctx.lineTo(c.to, 150);
                ctx.stroke();
                
                // Draw arrow
                const angle = c.to > c.from ? 0 : Math.PI;
                ctx.fillStyle = `rgba(214, 39, 40, ${alpha})`;
                ctx.beginPath();
                ctx.moveTo(c.to, 150);
                ctx.lineTo(c.to - Math.cos(angle - 0.5) * 12, 150 - Math.sin(angle - 0.5) * 12);
                ctx.lineTo(c.to - Math.cos(angle + 0.5) * 12, 150 - Math.sin(angle + 0.5) * 12);
                ctx.closePath();
                ctx.fill();
            });
            
            // Update physics
            sim.totalPredictions++;
            const aggressionFactor = sim.aggression / 50; // 0-2
            sim.clientX += sim.clientVel * aggressionFactor;
            
            // Server lags behind based on latency
            const lagFrames = sim.latency / 16;
            sim.serverX += (sim.clientX - sim.serverX) / (lagFrames + 1);
            
            // Bounce
            if (sim.clientX > canvas.width - 35) sim.clientVel = -3;
            if (sim.clientX < 35) sim.clientVel = 3;
            
            // Detect divergence
            const divergence = Math.abs(sim.clientX - sim.serverX);
            const threshold = 30 + (sim.latency / 5) + (sim.aggression / 2);
            if (divergence > threshold) {
                sim.corrections.push({from: sim.clientX, to: sim.serverX, time: sim.time});
                sim.clientX = sim.serverX;
                sim.correctionCount++;
                if (sim.corrections.length > 8) sim.corrections.shift();
            }
            
            // Age out corrections
            sim.corrections = sim.corrections.filter(c => sim.time - c.time < 60);
            
            sim.time++;
            updateMetrics();
            sim.animFrame = requestAnimationFrame(drawPredictionFrame);
        }
        
        function startPredictionSim() {
            if (!predictionSim.canvas) initPredictionSim();
            predictionSim.running = true;
            drawPredictionFrame();
        }
        
        function pausePredictionSim() {
            predictionSim.running = false;
            if (predictionSim.animFrame) cancelAnimationFrame(predictionSim.animFrame);
        }
        
        function resetPredictionSim() {
            pausePredictionSim();
            predictionSim.clientX = predictionSim.serverX = 100;
            predictionSim.corrections = [];
            predictionSim.time = 0;
            predictionSim.clientVel = 3;
            predictionSim.correctionCount = 0;
            predictionSim.totalPredictions = 0;
            if (predictionSim.ctx) drawPredictionInitialState();
        }
        
        function updatePredictionLatency(val) {
            predictionSim.latency = parseInt(val);
            document.getElementById('predictionLatency').textContent = val;
        }
        
        function updatePredictionAggression(val) {
            predictionSim.aggression = parseInt(val);
            document.getElementById('predictionAggression').textContent = val;
        }
        
        // ====================================
        // SIMULATION 2: PACKET LOSS & INTERPOLATION
        // ====================================
        let packetLossSim = {
            canvas: null,
            ctx: null,
            running: false,
            animFrame: null,
            entityX: 100,
            entityVel: 2.5,
            packets: [],
            lostPackets: [],
            interpolatedPos: 100,
            lossRate: 10,
            interpBuffer: 50,
            time: 0,
            totalPackets: 0,
            lostPacketCount: 0
        };
        
        function initPacketLossSim() {
            packetLossSim.canvas = document.getElementById('packetLossCanvas');
            if (!packetLossSim.canvas) return;
            packetLossSim.ctx = packetLossSim.canvas.getContext('2d');
            drawPacketLossInitialState();
        }
        
        function drawPacketLossInitialState() {
            if (!packetLossSim.ctx) return;
            const ctx = packetLossSim.ctx;
            const canvas = packetLossSim.canvas;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#8b949e';
            ctx.font = '16px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Click START to begin packet loss simulation', canvas.width / 2, canvas.height / 2);
        }
        
        function drawPacketLossFrame() {
            if (!packetLossSim.running) return;
            
            const ctx = packetLossSim.ctx;
            const canvas = packetLossSim.canvas;
            const sim = packetLossSim;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = '#21262d';
            ctx.lineWidth = 1;
            for (let i = 0; i < canvas.width; i += 50) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            
            // Update entity position
            sim.entityX += sim.entityVel;
            if (sim.entityX > canvas.width - 30) sim.entityVel = -2.5;
            if (sim.entityX < 30) sim.entityVel = 2.5;
            
            // Send packet every 10 frames (simulating snapshot rate)
            if (sim.time % 10 === 0) {
                sim.totalPackets++;
                const isLost = Math.random() * 100 < sim.lossRate;
                if (isLost) {
                    sim.lostPacketCount++;
                    sim.lostPackets.push({x: sim.entityX, time: sim.time});
                } else {
                    sim.packets.push({x: sim.entityX, time: sim.time});
                }
            }
            
            // Calculate interpolated position
            const bufferFrames = sim.interpBuffer / 16;
            if (sim.packets.length > 0) {
                const recentPackets = sim.packets.filter(p => sim.time - p.time < bufferFrames);
                if (recentPackets.length > 0) {
                    const avg = recentPackets.reduce((sum, p) => sum + p.x, 0) / recentPackets.length;
                    sim.interpolatedPos += (avg - sim.interpolatedPos) * 0.15;
                }
            }
            
            // Draw true entity position (green)
            ctx.fillStyle = '#3fb950';
            ctx.beginPath();
            ctx.arc(sim.entityX, 150, 20, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('TRUE', sim.entityX, 155);
            
            // Draw interpolated position (cyan)
            ctx.fillStyle = '#17a2b8';
            ctx.globalAlpha = 0.7;
            ctx.beginPath();
            ctx.arc(sim.interpolatedPos, 250, 20, 0, 2 * Math.PI);
            ctx.fill();
            ctx.globalAlpha = 1;
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 12px sans-serif';
            ctx.fillText('INTERP', sim.interpolatedPos, 255);
            
            // Draw received packets
            sim.packets.forEach((p, i) => {
                const alpha = 1 - (sim.time - p.time) / 120;
                if (alpha > 0) {
                    ctx.fillStyle = `rgba(63, 185, 80, ${alpha})`;
                    ctx.fillRect(p.x - 3, 300, 6, 20);
                }
            });
            
            // Draw lost packets
            sim.lostPackets.forEach((p, i) => {
                const alpha = 1 - (sim.time - p.time) / 120;
                if (alpha > 0) {
                    ctx.strokeStyle = `rgba(214, 39, 40, ${alpha})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(p.x - 5, 295);
                    ctx.lineTo(p.x + 5, 325);
                    ctx.moveTo(p.x + 5, 295);
                    ctx.lineTo(p.x - 5, 325);
                    ctx.stroke();
                }
            });
            
            // Age out old packets
            sim.packets = sim.packets.filter(p => sim.time - p.time < 180);
            sim.lostPackets = sim.lostPackets.filter(p => sim.time - p.time < 180);
            
            // Draw labels
            ctx.fillStyle = '#8b949e';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Packets Sent', 20, 310);
            ctx.fillText(`Loss: ${sim.lostPacketCount}/${sim.totalPackets} (${((sim.lostPacketCount/sim.totalPackets)*100).toFixed(1)}%)`, 20, 325);
            
            sim.time++;
            updateMetrics();
            sim.animFrame = requestAnimationFrame(drawPacketLossFrame);
        }
        
        function startPacketLossSim() {
            if (!packetLossSim.canvas) initPacketLossSim();
            packetLossSim.running = true;
            drawPacketLossFrame();
        }
        
        function pausePacketLossSim() {
            packetLossSim.running = false;
            if (packetLossSim.animFrame) cancelAnimationFrame(packetLossSim.animFrame);
        }
        
        function resetPacketLossSim() {
            pausePacketLossSim();
            packetLossSim.entityX = 100;
            packetLossSim.interpolatedPos = 100;
            packetLossSim.packets = [];
            packetLossSim.lostPackets = [];
            packetLossSim.time = 0;
            packetLossSim.totalPackets = 0;
            packetLossSim.lostPacketCount = 0;
            if (packetLossSim.ctx) drawPacketLossInitialState();
        }
        
        function updatePacketLossRate(val) {
            packetLossSim.lossRate = parseInt(val);
            document.getElementById('packetLossRate').textContent = val;
        }
        
        function updateInterpBuffer(val) {
            packetLossSim.interpBuffer = parseInt(val);
            document.getElementById('interpBuffer').textContent = val;
        }
        
        // ====================================
        // SIMULATION 3: TICK RATE COMPARISON
        // ====================================
        let tickRateSim = {
            canvas: null,
            ctx: null,
            running: false,
            animFrame: null,
            entityX: 100,
            entityVel: 3,
            tickRate: 60,
            tickHistory: [],
            baselineHistory: [],
            time: 0,
            tickCounter: 0
        };
        
        function initTickRateSim() {
            tickRateSim.canvas = document.getElementById('tickRateCanvas');
            if (!tickRateSim.canvas) return;
            tickRateSim.ctx = tickRateSim.canvas.getContext('2d');
            drawTickRateInitialState();
        }
        
        function drawTickRateInitialState() {
            if (!tickRateSim.ctx) return;
            const ctx = tickRateSim.ctx;
            const canvas = tickRateSim.canvas;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#8b949e';
            ctx.font = '16px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Click START to begin tick rate comparison', canvas.width / 2, canvas.height / 2);
        }
        
        function drawTickRateFrame() {
            if (!tickRateSim.running) return;
            
            const ctx = tickRateSim.ctx;
            const canvas = tickRateSim.canvas;
            const sim = tickRateSim;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = '#21262d';
            ctx.lineWidth = 1;
            for (let i = 0; i < canvas.height; i += 50) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }
            
            // Update entity
            sim.entityX += sim.entityVel;
            if (sim.entityX > canvas.width - 20) sim.entityVel = -3;
            if (sim.entityX < 20) sim.entityVel = 3;
            
            // Record ticks at current rate
            const tickInterval = 60 / sim.tickRate; // frames between ticks at current rate
            if (sim.time % Math.max(1, Math.floor(tickInterval)) === 0) {
                sim.tickHistory.push({x: sim.entityX, tick: sim.tickCounter});
                sim.tickCounter++;
            }
            
            // Always record baseline at 20Hz
            if (sim.time % 3 === 0) {
                sim.baselineHistory.push({x: sim.entityX, tick: Math.floor(sim.time / 3)});
            }
            
            // Keep history manageable
            if (sim.tickHistory.length > 40) sim.tickHistory.shift();
            if (sim.baselineHistory.length > 40) sim.baselineHistory.shift();
            
            // Draw current tick rate path (solid)
            ctx.strokeStyle = '#58a6ff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            sim.tickHistory.forEach((t, i) => {
                const y = 200 + Math.sin(t.x / 50) * 50;
                if (i === 0) ctx.moveTo(t.x, y);
                else ctx.lineTo(t.x, y);
            });
            ctx.stroke();
            
            // Draw tick points
            ctx.fillStyle = '#58a6ff';
            sim.tickHistory.forEach(t => {
                const y = 200 + Math.sin(t.x / 50) * 50;
                ctx.beginPath();
                ctx.arc(t.x, y, 4, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // Draw baseline (20Hz) path (dashed)
            ctx.strokeStyle = '#d29922';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            sim.baselineHistory.forEach((t, i) => {
                const y = 200 + Math.sin(t.x / 50) * 50;
                if (i === 0) ctx.moveTo(t.x, y);
                else ctx.lineTo(t.x, y);
            });
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw baseline points
            ctx.fillStyle = '#d29922';
            sim.baselineHistory.forEach(t => {
                const y = 200 + Math.sin(t.x / 50) * 50;
                ctx.beginPath();
                ctx.arc(t.x, y, 3, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // Draw current entity
            const currentY = 200 + Math.sin(sim.entityX / 50) * 50;
            ctx.fillStyle = '#3fb950';
            ctx.beginPath();
            ctx.arc(sim.entityX, currentY, 8, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw labels
            ctx.fillStyle = '#8b949e';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`Current: ${sim.tickRate}Hz (${sim.tickHistory.length} samples)`, 10, 30);
            ctx.fillText('Baseline: 20Hz', 10, 50);
            
            // Calculate and display precision difference
            if (sim.tickHistory.length > 1 && sim.baselineHistory.length > 1) {
                const avgSpacing = sim.tickHistory.reduce((sum, t, i) => {
                    if (i === 0) return 0;
                    return sum + Math.abs(t.x - sim.tickHistory[i-1].x);
                }, 0) / (sim.tickHistory.length - 1);
                
                ctx.fillText(`Avg tick spacing: ${avgSpacing.toFixed(1)}px`, 10, 70);
            }
            
            sim.time++;
            updateMetrics();
            sim.animFrame = requestAnimationFrame(drawTickRateFrame);
        }
        
        function startTickRateSim() {
            if (!tickRateSim.canvas) initTickRateSim();
            tickRateSim.running = true;
            drawTickRateFrame();
        }
        
        function pauseTickRateSim() {
            tickRateSim.running = false;
            if (tickRateSim.animFrame) cancelAnimationFrame(tickRateSim.animFrame);
        }
        
        function resetTickRateSim() {
            pauseTickRateSim();
            tickRateSim.entityX = 100;
            tickRateSim.tickHistory = [];
            tickRateSim.baselineHistory = [];
            tickRateSim.time = 0;
            tickRateSim.tickCounter = 0;
            if (tickRateSim.ctx) drawTickRateInitialState();
        }
        
        function updateTickRate(val) {
            tickRateSim.tickRate = parseInt(val);
            document.getElementById('tickRate').textContent = val;
        }
        
        // ====================================
        // METRICS DASHBOARD
        // ====================================
        function updateMetrics() {
            // Correction rate (from prediction sim)
            if (predictionSim.totalPredictions > 0) {
                const correctionRate = (predictionSim.correctionCount / (predictionSim.time / 60)).toFixed(2);
                document.getElementById('avgCorrectionRate').textContent = correctionRate;
            }
            
            // Prediction accuracy
            if (predictionSim.totalPredictions > 0) {
                const accuracy = ((predictionSim.totalPredictions - predictionSim.correctionCount) / predictionSim.totalPredictions * 100).toFixed(1);
                document.getElementById('predictionAccuracy').textContent = accuracy;
            }
            
            // Extrapolation time (from packet loss sim)
            if (packetLossSim.totalPackets > 0) {
                const extrapTime = (packetLossSim.interpBuffer * (packetLossSim.lostPacketCount / packetLossSim.totalPackets)).toFixed(1);
                document.getElementById('extrapolationTime').textContent = extrapTime;
            }
            
            // Bandwidth estimation
            if (tickRateSim.tickRate > 0) {
                // Rough estimate: snapshot size ~500 bytes, tick rate determines frequency
                const bandwidth = ((tickRateSim.tickRate * 500 * 8) / 1000).toFixed(1);
                document.getElementById('bandwidthUsage').textContent = bandwidth;
            }
        }
        
        // ====================================
        // INITIALIZATION
        // ====================================
        function initAllSimulations() {
            initPredictionSim();
            initPacketLossSim();
            initTickRateSim();
        }
        
        // Initialize on page load if simulation tab is visible
        window.addEventListener('load', () => {
            const simTab = document.getElementById('simulation');
            if (simTab && simTab.classList.contains('active')) {
                initAllSimulations();
                window.simulationsInitialized = true;
            }
        });
    </script>
</body>
</html>
